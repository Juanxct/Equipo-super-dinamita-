# -*- coding: utf-8 -*-
"""PYTHON_1_.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oqxdQFEVB4PkBLWrqGHAek27eLEGvMxv

# CONTEXTO DE LA BASE DE DATOS

La base de datos contiene **precios históricos diarios del contrato de futuros Micro Gold (MGC=F)** obtenidos desde Yahoo Finance. Incluye información de **apertura, máximo, mínimo, cierre y volumen negociado**, indexada por fecha, para el período comprendido entre **febrero de 2021 y febrero de 2026**.
Esta base permite analizar la **evolución del precio del oro**, estudiar su **comportamiento como serie de tiempo** y realizar análisis financieros, econométricos o de gestión del riesgo.


BY.

ALEJANDRA BENEDETTI CASTRO

JUAN TIBAMOSO OVALLE

# TRAER DATA
"""

!pip install yfinance
!pip install yfinance scipy statsmodels pydantic

import yfinance as yf
import pandas as pd
import numpy as np

from pydantic import BaseModel
from scipy.stats import jarque_bera
from statsmodels.tsa.stattools import adfuller
from statsmodels.stats.diagnostic import acorr_ljungbox
from pydantic import BaseModel, field_validator
from pydantic import BaseModel
from pydantic import BaseModel, validator
from pydantic import BaseModel, field_validator, ValidationError
import pandas as pd




ticker = "MGC=F"

df = yf.download(
    ticker,
    period="5y",
    interval="1d"
)

df.head()

"""# LIMPIEZA CON PANDAS"""

# Usar Adj Close si existe, si no usar Close
price_col = "Adj Close" if "Adj Close" in df.columns else "Close"

prices = df[price_col].dropna()

def descargar_datos(
    ticker: str = "MGC=F",
    periodo: str = "5y",
    intervalo: str = "1d"
) -> pd.DataFrame:
    """Descarga datos con yfinance y normaliza columnas."""

    df = yf.download(
        ticker,
        period=periodo,
        interval=intervalo
    )

    if isinstance(df.columns, pd.MultiIndex):
        df.columns = df.columns.get_level_values(0)

    return df

df = descargar_datos()
df.head()

#EDA
def ejecutar_eda(df: pd.DataFrame) -> dict:
    print("===== INFORMACIÓN GENERAL =====")
    print(f"Filas: {df.shape[0]}")
    print(f"Columnas: {df.shape[1]}")

    print("\n===== TIPOS DE DATOS =====")
    print(df.dtypes)

    print("\n===== VALORES NULOS =====")
    nulos = df.isnull().sum()
    print(nulos)

    print("\n===== DUPLICADOS =====")
    duplicados = df.duplicated().sum()
    print(f"Filas duplicadas: {duplicados}")

    print("\n===== ESTADÍSTICAS DESCRIPTIVAS =====")
    print(df.describe())

    return {
        "filas": df.shape[0],
        "columnas": df.shape[1],
        "nulos": nulos.to_dict(),
        "duplicados": duplicados
    }

reporte_eda = ejecutar_eda(df)

#VALIDACIÓN FINANCIERA
class RegistroFinanciero(BaseModel):
    Open: float
    High: float
    Low: float
    Close: float
    Volume: float

    @validator("Open", "High", "Low", "Close")
    def validar_precios_positivos(cls, v):
        if v <= 0:
            raise ValueError("El precio debe ser mayor que 0")
        return v

    @validator("Volume")
    def validar_volumen(cls, v):
        if v < 0:
            raise ValueError("El volumen no puede ser negativo")
        return v

#validar dataframe
def validar_dataframe(df: pd.DataFrame) -> pd.DataFrame:
    registros_validos = []
    errores = []

    columnas_modelo = ["Open", "High", "Low", "Close", "Volume"]

    for indice, fila in df.iterrows():
        try:
            datos = {
                col: float(fila[col].iloc[0]) if hasattr(fila[col], "iloc") else float(fila[col])
                for col in columnas_modelo
            }

            dato = RegistroFinanciero(**datos)
            registros_validos.append(dato.model_dump())

        except ValidationError as e:
            errores.append({
                "fila": indice,
                "error": e.errors()
            })

    if errores:
        print("❌ ERRORES DE VALIDACIÓN:")
        for err in errores[:5]:
            print(f"Fila {err['fila']}: {err['error']}")
        raise ValueError(f"Se encontraron {len(errores)} registros inválidos")

    return pd.DataFrame(registros_validos, index=df.index[:len(registros_validos)])

#PIPELINE
def procesar_dataset(df: pd.DataFrame) -> pd.DataFrame:
    print("Iniciando validación con Pydantic...")
    df_validado = validar_dataframe(df)
    print("Validación completada con éxito ✅")
    return df_validado

#MODELO PYDANTIC
class RegistroFinanciero(BaseModel):
    Open: float
    High: float
    Low: float
    Close: float
    Volume: float

    @field_validator("Open", "High", "Low", "Close")
    @classmethod
    def validar_precios_positivos(cls, v):
        if v <= 0:
            raise ValueError("El precio debe ser mayor que 0")
        return v

    @field_validator("Volume")
    @classmethod
    def validar_volumen(cls, v):
        if v < 0:
            raise ValueError("El volumen no puede ser negativo")
        return v

def validar_dataframe(df: pd.DataFrame) -> pd.DataFrame:
    registros_validos = []
    errores = []

    columnas_modelo = ["Open", "High", "Low", "Close", "Volume"]

    for indice, fila in df.iterrows():
        try:
            datos = {col: float(fila[col]) for col in columnas_modelo}
            dato = RegistroFinanciero(**datos)
            registros_validos.append(dato.model_dump())

        except ValidationError as e:
            errores.append({
                "fila": indice,
                "error": e.errors()
            })

    if errores:
        print("❌ ERRORES DE VALIDACIÓN DETECTADOS:")
        for err in errores[:5]:  # mostramos solo los primeros
            print(f"Fila {err['fila']}: {err['error']}")
        raise ValueError(f"Se encontraron {len(errores)} registros inválidos")

    return pd.DataFrame(registros_validos, index=df.index[:len(registros_validos)])

df_final = procesar_dataset(df)
df_final.head()

df_prueba = df.copy()
df_prueba.loc[df_prueba.index[0], "Open"] = -100
df_prueba.loc[df_prueba.index[1], "Volume"] = -50
df_prueba.loc[df_prueba.index[2], "High"] = 0

validar_dataframe(df_prueba)

"""# ESTADÍSTICAS Y MODULARIZACIÓN"""

#RETORNOS
returns = np.log(prices / prices.shift(1)).dropna()

#ESTADÍSTICAS BASICAS
mean_return = returns.mean()
std = returns.std()
skewness = returns.skew()
kurtosis = returns.kurtosis()

#RIESGOS
volatility_annual = std * np.sqrt(252)
var_95 = returns.quantile(0.05)

cum_returns = (1 + returns).cumprod()
rolling_max = cum_returns.cummax()
drawdown = cum_returns / rolling_max - 1
max_drawdown = drawdown.min()

#RATIOS
risk_free_rate = 0.0

sharpe = (mean_return - risk_free_rate) / std

downside_std = returns[returns < 0].std()
sortino = (mean_return - risk_free_rate) / downside_std

resultados = {
    "Mean Return": mean_return,
    "Std": std,
    "Skewness": skewness,
    "Kurtosis": kurtosis,
    "Volatilidad Anual": volatility_annual,
    "VaR 95%": var_95,
    "Max Drawdown": max_drawdown,
    "Sharpe": sharpe,
    "Sortino": sortino
}

pd.DataFrame(resultados.items(), columns=["Indicador", "Valor"])

"""Los resultados indican que en promedio el activo sí generó ganancias, pero con riesgo. La volatilidad muestra que el precio cambia bastante, y el VaR indica que en días malos pueden ocurrir pérdidas importantes. Además, los indicadores dicen que hubo movimientos extremos en algunas ocasiones. En resumen, el oro fue rentable en el período analizado, pero no estuvo libre de caídas fuertes.

# MODULARIZACIÓN CON Pydantic
"""

class Analysis(BaseModel):
    mean_return: float
    std: float
    skewness: float
    kurtosis: float

    volatility_annual: float
    var_95: float
    max_drawdown: float

    sharpe: float
    sortino: float

    jb_pval: float
    adf_pval: float
    lb_pval: float

analysis = Analysis(
    mean_return=mean_return,
    std=std,
    skewness=skewness,
    kurtosis=kurtosis,
    volatility_annual=volatility_annual,
    var_95=var_95,
    max_drawdown=max_drawdown,
    sharpe=sharpe,
    sortino=sortino,
    jb_pval=jb_pval,
    adf_pval=adf_pval,
    lb_pval=lb_pval
)

analysis.model_dump()

pd.DataFrame(
    analysis.model_dump().items(),
    columns=["Indicador", "Valor"]
)

import matplotlib.pyplot as plt

# Crear figura
plt.figure(figsize=(12,6))

# Precio
plt.plot(prices.index, prices, label="Precio", linewidth=2)

# Drawdown
plt.plot(drawdown.index, drawdown * prices.max(),
         label="Drawdown (escala precio)", linestyle="--")

# Líneas y formato
plt.title(f"Micro Gold Futures (MGC=F)\nPrecio y Drawdown", fontsize=14)
plt.xlabel("Fecha")
plt.ylabel("Precio")
plt.legend()
plt.grid(alpha=0.3)

plt.show()

"""La gráfica muestra que el precio del oro tiene una tendencia general al alza en el largo plazo, especialmente desde 2023, lo que indica crecimiento sostenido; sin embargo, no sube de manera constante, ya que presenta caídas temporales antes de recuperarse. El drawdown refleja esas bajadas desde el punto más alto alcanzado, mostrando que en el peor momento el precio cayó alrededor de un 21 %, lo que evidencia que, aunque el activo ha sido rentable en el período analizado, también ha tenido episodios importantes de riesgo.

"""